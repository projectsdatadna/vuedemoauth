{"ast":null,"code":"/*! @azure/msal-browser v2.31.0 2022-11-07 */\n'use strict';\n\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { StringUtils, Constants, UrlString } from '@azure/msal-common';\nimport { InteractionHandler } from './InteractionHandler.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { DEFAULT_IFRAME_TIMEOUT_MS } from '../config/Configuration.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar SilentHandler = /** @class */function (_super) {\n  __extends(SilentHandler, _super);\n  function SilentHandler(authCodeModule, storageImpl, authCodeRequest, logger, systemOptions) {\n    var _this = _super.call(this, authCodeModule, storageImpl, authCodeRequest, logger) || this;\n    _this.navigateFrameWait = systemOptions.navigateFrameWait;\n    _this.pollIntervalMilliseconds = systemOptions.pollIntervalMilliseconds;\n    return _this;\n  }\n  /**\r\n   * Creates a hidden iframe to given URL using user-requested scopes as an id.\r\n   * @param urlNavigate\r\n   * @param userRequestScopes\r\n   */\n  SilentHandler.prototype.initiateAuthRequest = function (requestUrl) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (StringUtils.isEmpty(requestUrl)) {\n              // Throw error if request URL is empty.\n              this.logger.info(\"Navigate url is empty\");\n              throw BrowserAuthError.createEmptyNavigationUriError();\n            }\n            if (!this.navigateFrameWait) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.loadFrame(requestUrl)];\n          case 1:\n            _a = _b.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            _a = this.loadFrameSync(requestUrl);\n            _b.label = 3;\n          case 3:\n            return [2 /*return*/, _a];\n        }\n      });\n    });\n  };\n  /**\r\n   * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.\r\n   * @param iframe\r\n   * @param timeout\r\n   */\n  SilentHandler.prototype.monitorIframeForHash = function (iframe, timeout) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {\n        _this.logger.warning(\"system.loadFrameTimeout or system.iframeHashTimeout set to lower (\" + timeout + \"ms) than the default (\" + DEFAULT_IFRAME_TIMEOUT_MS + \"ms). This may result in timeouts.\");\n      }\n      /*\r\n       * Polling for iframes can be purely timing based,\r\n       * since we don't need to account for interaction.\r\n       */\n      var nowMark = window.performance.now();\n      var timeoutMark = nowMark + timeout;\n      var intervalId = setInterval(function () {\n        if (window.performance.now() > timeoutMark) {\n          _this.removeHiddenIframe(iframe);\n          clearInterval(intervalId);\n          reject(BrowserAuthError.createMonitorIframeTimeoutError());\n          return;\n        }\n        var href = Constants.EMPTY_STRING;\n        var contentWindow = iframe.contentWindow;\n        try {\n          /*\r\n           * Will throw if cross origin,\r\n           * which should be caught and ignored\r\n           * since we need the interval to keep running while on STS UI.\r\n           */\n          href = contentWindow ? contentWindow.location.href : Constants.EMPTY_STRING;\n        } catch (e) {}\n        if (StringUtils.isEmpty(href)) {\n          return;\n        }\n        var contentHash = contentWindow ? contentWindow.location.hash : Constants.EMPTY_STRING;\n        if (UrlString.hashContainsKnownProperties(contentHash)) {\n          // Success case\n          _this.removeHiddenIframe(iframe);\n          clearInterval(intervalId);\n          resolve(contentHash);\n          return;\n        }\n      }, _this.pollIntervalMilliseconds);\n    });\n  };\n  /**\r\n   * @hidden\r\n   * Loads iframe with authorization endpoint URL\r\n   * @ignore\r\n   */\n  SilentHandler.prototype.loadFrame = function (urlNavigate) {\n    /*\r\n     * This trick overcomes iframe navigation in IE\r\n     * IE does not load the page consistently in iframe\r\n     */\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      var frameHandle = _this.createHiddenIframe();\n      setTimeout(function () {\n        if (!frameHandle) {\n          reject(\"Unable to load iframe\");\n          return;\n        }\n        frameHandle.src = urlNavigate;\n        resolve(frameHandle);\n      }, _this.navigateFrameWait);\n    });\n  };\n  /**\r\n   * @hidden\r\n   * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\r\n   * @param urlNavigate\r\n   * @param frameName\r\n   * @param logger\r\n   */\n  SilentHandler.prototype.loadFrameSync = function (urlNavigate) {\n    var frameHandle = this.createHiddenIframe();\n    frameHandle.src = urlNavigate;\n    return frameHandle;\n  };\n  /**\r\n   * @hidden\r\n   * Creates a new hidden iframe or gets an existing one for silent token renewal.\r\n   * @ignore\r\n   */\n  SilentHandler.prototype.createHiddenIframe = function () {\n    var authFrame = document.createElement(\"iframe\");\n    authFrame.style.visibility = \"hidden\";\n    authFrame.style.position = \"absolute\";\n    authFrame.style.width = authFrame.style.height = \"0\";\n    authFrame.style.border = \"0\";\n    authFrame.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n    document.getElementsByTagName(\"body\")[0].appendChild(authFrame);\n    return authFrame;\n  };\n  /**\r\n   * @hidden\r\n   * Removes a hidden iframe from the page.\r\n   * @ignore\r\n   */\n  SilentHandler.prototype.removeHiddenIframe = function (iframe) {\n    if (document.body === iframe.parentNode) {\n      document.body.removeChild(iframe);\n    }\n  };\n  return SilentHandler;\n}(InteractionHandler);\nexport { SilentHandler };","map":{"version":3,"mappings":"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","names":["__extends","authCodeModule","storageImpl","authCodeRequest","logger","systemOptions","_super","_this","navigateFrameWait","pollIntervalMilliseconds","SilentHandler","requestUrl","StringUtils","isEmpty","info","BrowserAuthError","createEmptyNavigationUriError","loadFrame","_a","loadFrameSync","iframe","timeout","Promise","resolve","reject","DEFAULT_IFRAME_TIMEOUT_MS","warning","nowMark","window","performance","now","timeoutMark","intervalId","setInterval","removeHiddenIframe","clearInterval","createMonitorIframeTimeoutError","href","Constants","EMPTY_STRING","contentWindow","location","e","contentHash","hash","UrlString","hashContainsKnownProperties","urlNavigate","frameHandle","createHiddenIframe","setTimeout","src","authFrame","document","createElement","style","visibility","position","width","height","border","setAttribute","getElementsByTagName","appendChild","body","parentNode","removeChild","InteractionHandler"],"sources":["C:\\Azure\\gitauthdemo\\ms-identity-javascript-react-tutorial\\3-Authorization-II\\2-call-api-b2c\\SPA\\node_modules\\@azure\\msal-browser\\src\\interaction_handler\\SilentHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { UrlString, StringUtils, CommonAuthorizationCodeRequest, AuthorizationCodeClient, Constants, Logger } from \"@azure/msal-common\";\nimport { InteractionHandler } from \"./InteractionHandler\";\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\nimport { BrowserSystemOptions, DEFAULT_IFRAME_TIMEOUT_MS } from \"../config/Configuration\";\n\nexport class SilentHandler extends InteractionHandler {\n\n    private navigateFrameWait: number;\n    private pollIntervalMilliseconds: number;\n\n    constructor(authCodeModule: AuthorizationCodeClient, storageImpl: BrowserCacheManager, authCodeRequest: CommonAuthorizationCodeRequest, logger: Logger, systemOptions: Required<Pick<BrowserSystemOptions, \"navigateFrameWait\" | \"pollIntervalMilliseconds\">>) {\n        super(authCodeModule, storageImpl, authCodeRequest, logger);\n        this.navigateFrameWait = systemOptions.navigateFrameWait;\n        this.pollIntervalMilliseconds = systemOptions.pollIntervalMilliseconds;\n    }\n\n    /**\n     * Creates a hidden iframe to given URL using user-requested scopes as an id.\n     * @param urlNavigate\n     * @param userRequestScopes\n     */\n    async initiateAuthRequest(requestUrl: string): Promise<HTMLIFrameElement> {\n        if (StringUtils.isEmpty(requestUrl)) {\n            // Throw error if request URL is empty.\n            this.logger.info(\"Navigate url is empty\");\n            throw BrowserAuthError.createEmptyNavigationUriError();\n        }\n\n        return this.navigateFrameWait ? await this.loadFrame(requestUrl) : this.loadFrameSync(requestUrl);\n    }\n\n    /**\n     * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.\n     * @param iframe\n     * @param timeout\n     */\n    monitorIframeForHash(iframe: HTMLIFrameElement, timeout: number): Promise<string> {\n        return new Promise((resolve, reject) => {\n            if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {\n                this.logger.warning(`system.loadFrameTimeout or system.iframeHashTimeout set to lower (${timeout}ms) than the default (${DEFAULT_IFRAME_TIMEOUT_MS}ms). This may result in timeouts.`);\n            }\n\n            /*\n             * Polling for iframes can be purely timing based,\n             * since we don't need to account for interaction.\n             */\n            const nowMark = window.performance.now();\n            const timeoutMark = nowMark + timeout;\n\n            const intervalId = setInterval(() => {\n                if (window.performance.now() > timeoutMark) {\n                    this.removeHiddenIframe(iframe);\n                    clearInterval(intervalId);\n                    reject(BrowserAuthError.createMonitorIframeTimeoutError());\n                    return;\n                }\n\n                let href: string = Constants.EMPTY_STRING;\n                const contentWindow = iframe.contentWindow;\n                try {\n                    /*\n                     * Will throw if cross origin,\n                     * which should be caught and ignored\n                     * since we need the interval to keep running while on STS UI.\n                     */\n                    href = contentWindow ? contentWindow.location.href : Constants.EMPTY_STRING;\n                } catch (e) {}\n\n                if (StringUtils.isEmpty(href)) {\n                    return;\n                }\n\n                const contentHash = contentWindow ? contentWindow.location.hash: Constants.EMPTY_STRING;\n                if (UrlString.hashContainsKnownProperties(contentHash)) {\n                    // Success case\n                    this.removeHiddenIframe(iframe);\n                    clearInterval(intervalId);\n                    resolve(contentHash);\n                    return;\n                }\n            }, this.pollIntervalMilliseconds);\n        });\n    }\n\n    /**\n     * @hidden\n     * Loads iframe with authorization endpoint URL\n     * @ignore\n     */\n    private loadFrame(urlNavigate: string): Promise<HTMLIFrameElement> {\n        /*\n         * This trick overcomes iframe navigation in IE\n         * IE does not load the page consistently in iframe\n         */\n\n        return new Promise((resolve, reject) => {\n            const frameHandle = this.createHiddenIframe();\n\n            setTimeout(() => {\n                if (!frameHandle) {\n                    reject(\"Unable to load iframe\");\n                    return;\n                }\n\n                frameHandle.src = urlNavigate;\n\n                resolve(frameHandle);\n            }, this.navigateFrameWait);\n        });\n    }\n\n    /**\n     * @hidden\n     * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\n     * @param urlNavigate\n     * @param frameName\n     * @param logger\n     */\n    private loadFrameSync(urlNavigate: string): HTMLIFrameElement{\n        const frameHandle = this.createHiddenIframe();\n\n        frameHandle.src = urlNavigate;\n\n        return frameHandle;\n    }\n\n    /**\n     * @hidden\n     * Creates a new hidden iframe or gets an existing one for silent token renewal.\n     * @ignore\n     */\n    private createHiddenIframe(): HTMLIFrameElement {\n        const authFrame = document.createElement(\"iframe\");\n\n        authFrame.style.visibility = \"hidden\";\n        authFrame.style.position = \"absolute\";\n        authFrame.style.width = authFrame.style.height = \"0\";\n        authFrame.style.border = \"0\";\n        authFrame.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n        document.getElementsByTagName(\"body\")[0].appendChild(authFrame);\n\n        return authFrame;\n    }\n\n    /**\n     * @hidden\n     * Removes a hidden iframe from the page.\n     * @ignore\n     */\n    private removeHiddenIframe(iframe: HTMLIFrameElement): void {\n        if (document.body === iframe.parentNode) {\n            document.body.removeChild(iframe);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}