{"ast":null,"code":"/*! @azure/msal-browser v2.31.0 2022-11-07 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BrowserAuthError, BrowserAuthErrorMessage } from '../error/BrowserAuthError.js';\nimport { DatabaseStorage } from './DatabaseStorage.js';\nimport { MemoryStorage } from './MemoryStorage.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\r\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\r\n */\nvar AsyncMemoryStorage = /** @class */function () {\n  function AsyncMemoryStorage(logger, storeName) {\n    this.inMemoryCache = new MemoryStorage();\n    this.indexedDBCache = new DatabaseStorage();\n    this.logger = logger;\n    this.storeName = storeName;\n  }\n  AsyncMemoryStorage.prototype.handleDatabaseAccessError = function (error) {\n    if (error instanceof BrowserAuthError && error.errorCode === BrowserAuthErrorMessage.databaseUnavailable.code) {\n      this.logger.error(\"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\");\n    } else {\n      throw error;\n    }\n  };\n  /**\r\n   * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\r\n   * storage object if item isn't found in-memory.\r\n   * @param key\r\n   */\n  AsyncMemoryStorage.prototype.getItem = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var item, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            item = this.inMemoryCache.getItem(key);\n            if (!!item) return [3 /*break*/, 4];\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            this.logger.verbose(\"Queried item not found in in-memory cache, now querying persistent storage.\");\n            return [4 /*yield*/, this.indexedDBCache.getItem(key)];\n          case 2:\n            return [2 /*return*/, _a.sent()];\n          case 3:\n            e_1 = _a.sent();\n            this.handleDatabaseAccessError(e_1);\n            return [3 /*break*/, 4];\n          case 4:\n            return [2 /*return*/, item];\n        }\n      });\n    });\n  };\n  /**\r\n   * Sets the item in the in-memory cache and then tries to set it in the asynchronous\r\n   * storage object with the given key.\r\n   * @param key\r\n   * @param value\r\n   */\n  AsyncMemoryStorage.prototype.setItem = function (key, value) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.inMemoryCache.setItem(key, value);\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.indexedDBCache.setItem(key, value)];\n          case 2:\n            _a.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            e_2 = _a.sent();\n            this.handleDatabaseAccessError(e_2);\n            return [3 /*break*/, 4];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\r\n   * @param key\r\n   */\n  AsyncMemoryStorage.prototype.removeItem = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.inMemoryCache.removeItem(key);\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.indexedDBCache.removeItem(key)];\n          case 2:\n            _a.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            e_3 = _a.sent();\n            this.handleDatabaseAccessError(e_3);\n            return [3 /*break*/, 4];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the\r\n   * asynchronous storage object.\r\n   */\n  AsyncMemoryStorage.prototype.getKeys = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var cacheKeys, e_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            cacheKeys = this.inMemoryCache.getKeys();\n            if (!(cacheKeys.length === 0)) return [3 /*break*/, 4];\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            this.logger.verbose(\"In-memory cache is empty, now querying persistent storage.\");\n            return [4 /*yield*/, this.indexedDBCache.getKeys()];\n          case 2:\n            return [2 /*return*/, _a.sent()];\n          case 3:\n            e_4 = _a.sent();\n            this.handleDatabaseAccessError(e_4);\n            return [3 /*break*/, 4];\n          case 4:\n            return [2 /*return*/, cacheKeys];\n        }\n      });\n    });\n  };\n  /**\r\n   * Returns true or false if the given key is present in the cache.\r\n   * @param key\r\n   */\n  AsyncMemoryStorage.prototype.containsKey = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var containsKey, e_5;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            containsKey = this.inMemoryCache.containsKey(key);\n            if (!!containsKey) return [3 /*break*/, 4];\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            this.logger.verbose(\"Key not found in in-memory cache, now querying persistent storage.\");\n            return [4 /*yield*/, this.indexedDBCache.containsKey(key)];\n          case 2:\n            return [2 /*return*/, _a.sent()];\n          case 3:\n            e_5 = _a.sent();\n            this.handleDatabaseAccessError(e_5);\n            return [3 /*break*/, 4];\n          case 4:\n            return [2 /*return*/, containsKey];\n        }\n      });\n    });\n  };\n  /**\r\n   * Clears in-memory Map\r\n   */\n  AsyncMemoryStorage.prototype.clearInMemory = function () {\n    // InMemory cache is a Map instance, clear is straightforward\n    this.logger.verbose(\"Deleting in-memory keystore \" + this.storeName);\n    this.inMemoryCache.clear();\n    this.logger.verbose(\"In-memory keystore \" + this.storeName + \" deleted\");\n  };\n  /**\r\n   * Tries to delete the IndexedDB database\r\n   * @returns\r\n   */\n  AsyncMemoryStorage.prototype.clearPersistent = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var dbDeleted, e_6;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            this.logger.verbose(\"Deleting persistent keystore\");\n            return [4 /*yield*/, this.indexedDBCache.deleteDatabase()];\n          case 1:\n            dbDeleted = _a.sent();\n            if (dbDeleted) {\n              this.logger.verbose(\"Persistent keystore deleted\");\n            }\n            return [2 /*return*/, dbDeleted];\n          case 2:\n            e_6 = _a.sent();\n            this.handleDatabaseAccessError(e_6);\n            return [2 /*return*/, false];\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return AsyncMemoryStorage;\n}();\nexport { AsyncMemoryStorage };","map":{"version":3,"mappings":"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","names":["logger","storeName","inMemoryCache","MemoryStorage","indexedDBCache","DatabaseStorage","AsyncMemoryStorage","error","BrowserAuthError","errorCode","BrowserAuthErrorMessage","databaseUnavailable","code","key","item","getItem","verbose","_a","handleDatabaseAccessError","e_1","value","setItem","e_2","removeItem","e_3","cacheKeys","getKeys","length","e_4","containsKey","e_5","clear","deleteDatabase","dbDeleted","e_6"],"sources":["C:\\Azure\\gitauthdemo\\ms-identity-javascript-react-tutorial\\3-Authorization-II\\2-call-api-b2c\\SPA\\node_modules\\@azure\\msal-browser\\src\\cache\\AsyncMemoryStorage.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Logger } from \"@azure/msal-common\";\nimport { BrowserAuthError, BrowserAuthErrorMessage } from \"../error/BrowserAuthError\";\nimport { DatabaseStorage } from \"./DatabaseStorage\";\nimport { IAsyncStorage } from \"./IAsyncMemoryStorage\";\nimport { MemoryStorage } from \"./MemoryStorage\";\n\n/**\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\n */\nexport class AsyncMemoryStorage<T> implements IAsyncStorage<T> {\n    private inMemoryCache: MemoryStorage<T>;\n    private indexedDBCache: DatabaseStorage<T>;\n    private logger: Logger;\n    private storeName: string;\n\n    constructor(logger: Logger, storeName: string) {\n        this.inMemoryCache = new MemoryStorage<T>();\n        this.indexedDBCache = new DatabaseStorage<T>();\n        this.logger = logger;\n        this.storeName = storeName;\n    }\n\n    private handleDatabaseAccessError(error: unknown): void {\n        if (error instanceof BrowserAuthError && error.errorCode === BrowserAuthErrorMessage.databaseUnavailable.code) {\n            this.logger.error(\"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\");\n        } else {\n            throw error;\n        }\n    }\n    /**\n     * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\n     * storage object if item isn't found in-memory.\n     * @param key \n     */\n    async getItem(key: string): Promise<T | null> {\n        const item = this.inMemoryCache.getItem(key);\n        if(!item) {\n            try {\n                this.logger.verbose(\"Queried item not found in in-memory cache, now querying persistent storage.\");\n                return await this.indexedDBCache.getItem(key);\n            } catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return item;\n    }\n\n    /**\n     * Sets the item in the in-memory cache and then tries to set it in the asynchronous\n     * storage object with the given key.\n     * @param key \n     * @param value \n     */\n    async setItem(key: string, value: T): Promise<void> {\n        this.inMemoryCache.setItem(key, value);\n        try {\n            await this.indexedDBCache.setItem(key, value);\n        } catch (e) {\n            this.handleDatabaseAccessError(e);\n        }\n    }\n\n    /**\n     * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\n     * @param key \n     */\n    async removeItem(key: string): Promise<void> {\n        this.inMemoryCache.removeItem(key);\n        try {\n            await this.indexedDBCache.removeItem(key);\n        } catch (e) {\n            this.handleDatabaseAccessError(e);\n        }\n    }\n\n    /**\n     * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the \n     * asynchronous storage object.\n     */\n    async getKeys(): Promise<string[]> {\n        const cacheKeys = this.inMemoryCache.getKeys();\n        if (cacheKeys.length === 0) {\n            try {\n                this.logger.verbose(\"In-memory cache is empty, now querying persistent storage.\");\n                return await this.indexedDBCache.getKeys();\n            } catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return cacheKeys;\n    }\n\n    /**\n     * Returns true or false if the given key is present in the cache.\n     * @param key \n     */\n    async containsKey(key: string): Promise<boolean> {\n        const containsKey = this.inMemoryCache.containsKey(key);\n        if(!containsKey) {\n            try {\n                this.logger.verbose(\"Key not found in in-memory cache, now querying persistent storage.\");\n                return await this.indexedDBCache.containsKey(key);\n            } catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return containsKey;\n    }\n\n    /**\n     * Clears in-memory Map\n     */\n    clearInMemory(): void {\n        // InMemory cache is a Map instance, clear is straightforward\n        this.logger.verbose(`Deleting in-memory keystore ${this.storeName}`);\n        this.inMemoryCache.clear();\n        this.logger.verbose(`In-memory keystore ${this.storeName} deleted`);\n    }\n\n    /**\n     * Tries to delete the IndexedDB database\n     * @returns\n     */\n    async clearPersistent(): Promise<boolean> {\n        try {\n            this.logger.verbose(\"Deleting persistent keystore\");\n            const dbDeleted = await this.indexedDBCache.deleteDatabase();\n            if (dbDeleted) {\n                this.logger.verbose(\"Persistent keystore deleted\");\n            }\n            \n            return dbDeleted;\n        } catch (e) {\n            this.handleDatabaseAccessError(e);\n            return false;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}