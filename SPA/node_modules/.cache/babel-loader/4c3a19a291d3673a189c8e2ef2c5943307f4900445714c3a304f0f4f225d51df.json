{"ast":null,"code":"/*! @azure/msal-browser v2.31.0 2022-11-07 */\n'use strict';\n\nimport { __awaiter, __generator } from '../../_virtual/_tslib.js';\nimport { NativeConstants, NativeExtensionMethod } from '../../utils/BrowserConstants.js';\nimport { AuthError, AuthenticationScheme } from '@azure/msal-common';\nimport { NativeAuthError } from '../../error/NativeAuthError.js';\nimport { BrowserAuthError } from '../../error/BrowserAuthError.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar NativeMessageHandler = /** @class */function () {\n  function NativeMessageHandler(logger, handshakeTimeoutMs, extensionId) {\n    this.logger = logger;\n    this.handshakeTimeoutMs = handshakeTimeoutMs;\n    this.extensionId = extensionId;\n    this.resolvers = new Map(); // Used for non-handshake messages\n    this.handshakeResolvers = new Map(); // Used for handshake messages\n    this.responseId = 0;\n    this.messageChannel = new MessageChannel();\n    this.windowListener = this.onWindowMessage.bind(this); // Window event callback doesn't have access to 'this' unless it's bound\n  }\n  /**\r\n   * Sends a given message to the extension and resolves with the extension response\r\n   * @param body\r\n   */\n  NativeMessageHandler.prototype.sendMessage = function (body) {\n    return __awaiter(this, void 0, void 0, function () {\n      var req;\n      var _this = this;\n      return __generator(this, function (_a) {\n        this.logger.trace(\"NativeMessageHandler - sendMessage called.\");\n        req = {\n          channel: NativeConstants.CHANNEL_ID,\n          extensionId: this.extensionId,\n          responseId: this.responseId++,\n          body: body\n        };\n        this.logger.trace(\"NativeMessageHandler - Sending request to browser extension\");\n        this.logger.tracePii(\"NativeMessageHandler - Sending request to browser extension: \" + JSON.stringify(req));\n        this.messageChannel.port1.postMessage(req);\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          _this.resolvers.set(req.responseId, {\n            resolve: resolve,\n            reject: reject\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * Returns an instance of the MessageHandler that has successfully established a connection with an extension\r\n   * @param logger\r\n   * @param handshakeTimeoutMs\r\n   */\n  NativeMessageHandler.createProvider = function (logger, handshakeTimeoutMs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var preferredProvider, backupProvider;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.trace(\"NativeMessageHandler - createProvider called.\");\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 5]);\n            preferredProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, NativeConstants.PREFERRED_EXTENSION_ID);\n            return [4 /*yield*/, preferredProvider.sendHandshakeRequest()];\n          case 2:\n            _a.sent();\n            return [2 /*return*/, preferredProvider];\n          case 3:\n            _a.sent();\n            backupProvider = new NativeMessageHandler(logger, handshakeTimeoutMs);\n            return [4 /*yield*/, backupProvider.sendHandshakeRequest()];\n          case 4:\n            _a.sent();\n            return [2 /*return*/, backupProvider];\n          case 5:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Send handshake request helper.\r\n   */\n  NativeMessageHandler.prototype.sendHandshakeRequest = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var req;\n      var _this = this;\n      return __generator(this, function (_a) {\n        this.logger.trace(\"NativeMessageHandler - sendHandshakeRequest called.\");\n        // Register this event listener before sending handshake\n        window.addEventListener(\"message\", this.windowListener, false); // false is important, because content script message processing should work first\n        req = {\n          channel: NativeConstants.CHANNEL_ID,\n          extensionId: this.extensionId,\n          responseId: this.responseId++,\n          body: {\n            method: NativeExtensionMethod.HandshakeRequest\n          }\n        };\n        this.messageChannel.port1.onmessage = function (event) {\n          _this.onChannelMessage(event);\n        };\n        window.postMessage(req, window.origin, [this.messageChannel.port2]);\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          _this.handshakeResolvers.set(req.responseId, {\n            resolve: resolve,\n            reject: reject\n          });\n          _this.timeoutId = window.setTimeout(function () {\n            /*\r\n             * Throw an error if neither HandshakeResponse nor original Handshake request are received in a reasonable timeframe.\r\n             * This typically suggests an event handler stopped propagation of the Handshake request but did not respond to it on the MessageChannel port\r\n             */\n            window.removeEventListener(\"message\", _this.windowListener, false);\n            _this.messageChannel.port1.close();\n            _this.messageChannel.port2.close();\n            reject(BrowserAuthError.createNativeHandshakeTimeoutError());\n            _this.handshakeResolvers.delete(req.responseId);\n          }, _this.handshakeTimeoutMs); // Use a reasonable timeout in milliseconds here\n        })];\n      });\n    });\n  };\n  /**\r\n   * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.\r\n   * @param event\r\n   */\n  NativeMessageHandler.prototype.onWindowMessage = function (event) {\n    this.logger.trace(\"NativeMessageHandler - onWindowMessage called\");\n    // We only accept messages from ourselves\n    if (event.source !== window) {\n      return;\n    }\n    var request = event.data;\n    if (!request.channel || request.channel !== NativeConstants.CHANNEL_ID) {\n      return;\n    }\n    if (request.extensionId && request.extensionId !== this.extensionId) {\n      return;\n    }\n    if (request.body.method === NativeExtensionMethod.HandshakeRequest) {\n      // If we receive this message back it means no extension intercepted the request, meaning no extension supporting handshake protocol is installed\n      this.logger.verbose(request.extensionId ? \"Extension with id: \" + request.extensionId + \" not installed\" : \"No extension installed\");\n      clearTimeout(this.timeoutId);\n      this.messageChannel.port1.close();\n      this.messageChannel.port2.close();\n      window.removeEventListener(\"message\", this.windowListener, false);\n      var handshakeResolver = this.handshakeResolvers.get(request.responseId);\n      if (handshakeResolver) {\n        handshakeResolver.reject(BrowserAuthError.createNativeExtensionNotInstalledError());\n      }\n    }\n  };\n  /**\r\n   * Invoked when a message is received from the extension on the MessageChannel port\r\n   * @param event\r\n   */\n  NativeMessageHandler.prototype.onChannelMessage = function (event) {\n    this.logger.trace(\"NativeMessageHandler - onChannelMessage called.\");\n    var request = event.data;\n    var resolver = this.resolvers.get(request.responseId);\n    var handshakeResolver = this.handshakeResolvers.get(request.responseId);\n    try {\n      var method = request.body.method;\n      if (method === NativeExtensionMethod.Response) {\n        if (!resolver) {\n          return;\n        }\n        var response = request.body.response;\n        this.logger.trace(\"NativeMessageHandler - Received response from browser extension\");\n        this.logger.tracePii(\"NativeMessageHandler - Received response from browser extension: \" + JSON.stringify(response));\n        if (response.status !== \"Success\") {\n          resolver.reject(NativeAuthError.createError(response.code, response.description, response.ext));\n        } else if (response.result) {\n          if (response.result[\"code\"] && response.result[\"description\"]) {\n            resolver.reject(NativeAuthError.createError(response.result[\"code\"], response.result[\"description\"], response.result[\"ext\"]));\n          } else {\n            resolver.resolve(response.result);\n          }\n        } else {\n          throw AuthError.createUnexpectedError(\"Event does not contain result.\");\n        }\n        this.resolvers.delete(request.responseId);\n      } else if (method === NativeExtensionMethod.HandshakeResponse) {\n        if (!handshakeResolver) {\n          return;\n        }\n        clearTimeout(this.timeoutId); // Clear setTimeout\n        window.removeEventListener(\"message\", this.windowListener, false); // Remove 'No extension' listener\n        this.extensionId = request.extensionId;\n        this.extensionVersion = request.body.version;\n        this.logger.verbose(\"NativeMessageHandler - Received HandshakeResponse from extension: \" + this.extensionId);\n        handshakeResolver.resolve();\n        this.handshakeResolvers.delete(request.responseId);\n      }\n      // Do nothing if method is not Response or HandshakeResponse\n    } catch (err) {\n      this.logger.error(\"Error parsing response from WAM Extension\");\n      this.logger.errorPii(\"Error parsing response from WAM Extension: \" + err.toString());\n      this.logger.errorPii(\"Unable to parse \" + event);\n      if (resolver) {\n        resolver.reject(err);\n      } else if (handshakeResolver) {\n        handshakeResolver.reject(err);\n      }\n    }\n  };\n  /**\r\n   * Returns the Id for the browser extension this handler is communicating with\r\n   * @returns\r\n   */\n  NativeMessageHandler.prototype.getExtensionId = function () {\n    return this.extensionId;\n  };\n  /**\r\n   * Returns the version for the browser extension this handler is communicating with\r\n   * @returns\r\n   */\n  NativeMessageHandler.prototype.getExtensionVersion = function () {\n    return this.extensionVersion;\n  };\n  /**\r\n   * Returns boolean indicating whether or not the request should attempt to use native broker\r\n   * @param logger\r\n   * @param config\r\n   * @param nativeExtensionProvider\r\n   * @param authenticationScheme\r\n   */\n  NativeMessageHandler.isNativeAvailable = function (config, logger, nativeExtensionProvider, authenticationScheme) {\n    logger.trace(\"isNativeAvailable called\");\n    if (!config.system.allowNativeBroker) {\n      logger.trace(\"isNativeAvailable: allowNativeBroker is not enabled, returning false\");\n      // Developer disabled WAM\n      return false;\n    }\n    if (!nativeExtensionProvider) {\n      logger.trace(\"isNativeAvailable: WAM extension provider is not initialized, returning false\");\n      // Extension is not available\n      return false;\n    }\n    if (authenticationScheme) {\n      switch (authenticationScheme) {\n        case AuthenticationScheme.BEARER:\n        case AuthenticationScheme.POP:\n          logger.trace(\"isNativeAvailable: authenticationScheme is supported, returning true\");\n          return true;\n        default:\n          logger.trace(\"isNativeAvailable: authenticationScheme is not supported, returning false\");\n          return false;\n      }\n    }\n    return true;\n  };\n  return NativeMessageHandler;\n}();\nexport { NativeMessageHandler };","map":{"version":3,"mappings":"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","names":["logger","handshakeTimeoutMs","extensionId","resolvers","Map","handshakeResolvers","responseId","messageChannel","MessageChannel","windowListener","onWindowMessage","bind","NativeMessageHandler","body","trace","req","channel","NativeConstants","CHANNEL_ID","tracePii","JSON","stringify","port1","postMessage","Promise","resolve","reject","_this","set","preferredProvider","PREFERRED_EXTENSION_ID","sendHandshakeRequest","_a","backupProvider","window","addEventListener","method","NativeExtensionMethod","HandshakeRequest","onmessage","event","onChannelMessage","origin","port2","timeoutId","setTimeout","removeEventListener","close","BrowserAuthError","createNativeHandshakeTimeoutError","delete","source","request","data","verbose","clearTimeout","handshakeResolver","get","createNativeExtensionNotInstalledError","resolver","Response","response","status","NativeAuthError","createError","code","description","ext","result","AuthError","createUnexpectedError","HandshakeResponse","extensionVersion","version","err","error","errorPii","toString","config","nativeExtensionProvider","authenticationScheme","system","allowNativeBroker","AuthenticationScheme","BEARER","POP"],"sources":["C:\\Azure\\gitauthdemo\\ms-identity-javascript-react-tutorial\\3-Authorization-II\\2-call-api-b2c\\SPA\\node_modules\\@azure\\msal-browser\\src\\broker\\nativeBroker\\NativeMessageHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { NativeConstants, NativeExtensionMethod } from \"../../utils/BrowserConstants\";\nimport { Logger, AuthError, AuthenticationScheme } from \"@azure/msal-common\";\nimport { NativeExtensionRequest, NativeExtensionRequestBody } from \"./NativeRequest\";\nimport { NativeAuthError } from \"../../error/NativeAuthError\";\nimport { BrowserAuthError } from \"../../error/BrowserAuthError\";\nimport { BrowserConfiguration } from \"../../config/Configuration\";\n\ntype ResponseResolvers<T> = {\n    resolve: (value:T|PromiseLike<T>) => void;\n    reject: (value:AuthError|Error|PromiseLike<Error>|PromiseLike<AuthError>)  => void;\n};\n\nexport class NativeMessageHandler {\n    private extensionId: string | undefined;\n    private extensionVersion: string | undefined;\n    private logger: Logger;\n    private handshakeTimeoutMs: number;\n    private responseId: number;\n    private timeoutId: number | undefined;\n    private resolvers: Map<number, ResponseResolvers<object>>;\n    private handshakeResolvers: Map<number, ResponseResolvers<void>>;\n    private messageChannel: MessageChannel;\n    private windowListener: (event: MessageEvent) => void;\n\n    constructor(logger: Logger, handshakeTimeoutMs: number, extensionId?: string) {\n        this.logger = logger;\n        this.handshakeTimeoutMs = handshakeTimeoutMs;\n        this.extensionId = extensionId;\n        this.resolvers = new Map(); // Used for non-handshake messages\n        this.handshakeResolvers = new Map(); // Used for handshake messages\n        this.responseId = 0;\n        this.messageChannel = new MessageChannel();\n        this.windowListener = this.onWindowMessage.bind(this); // Window event callback doesn't have access to 'this' unless it's bound\n    }\n\n    /**\n     * Sends a given message to the extension and resolves with the extension response\n     * @param body \n     */\n    async sendMessage(body: NativeExtensionRequestBody): Promise<object> {\n        this.logger.trace(\"NativeMessageHandler - sendMessage called.\");\n        const req: NativeExtensionRequest = {\n            channel: NativeConstants.CHANNEL_ID,\n            extensionId: this.extensionId,\n            responseId: this.responseId++,\n            body: body\n        };\n\n        this.logger.trace(\"NativeMessageHandler - Sending request to browser extension\");\n        this.logger.tracePii(`NativeMessageHandler - Sending request to browser extension: ${JSON.stringify(req)}`);\n        this.messageChannel.port1.postMessage(req);\n\n        return new Promise((resolve, reject) => {\n            this.resolvers.set(req.responseId, {resolve, reject});\n        });\n    }\n\n    /**\n     * Returns an instance of the MessageHandler that has successfully established a connection with an extension\n     * @param logger \n     * @param handshakeTimeoutMs\n     */\n    static async createProvider(logger: Logger, handshakeTimeoutMs: number): Promise<NativeMessageHandler> {\n        logger.trace(\"NativeMessageHandler - createProvider called.\");\n        try {\n            const preferredProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, NativeConstants.PREFERRED_EXTENSION_ID);\n            await preferredProvider.sendHandshakeRequest();\n            return preferredProvider;\n        } catch (e) {\n            // If preferred extension fails for whatever reason, fallback to using any installed extension\n            const backupProvider = new NativeMessageHandler(logger, handshakeTimeoutMs);\n            await backupProvider.sendHandshakeRequest();\n            return backupProvider;\n        }\n    }\n\n    /**\n     * Send handshake request helper.\n     */\n    private async sendHandshakeRequest(): Promise<void> {\n        this.logger.trace(\"NativeMessageHandler - sendHandshakeRequest called.\");\n        // Register this event listener before sending handshake\n        window.addEventListener(\"message\", this.windowListener, false); // false is important, because content script message processing should work first\n\n        const req: NativeExtensionRequest = {\n            channel: NativeConstants.CHANNEL_ID,\n            extensionId: this.extensionId,\n            responseId: this.responseId++,\n\n            body: {\n                method: NativeExtensionMethod.HandshakeRequest\n            }\n        };\n\n        this.messageChannel.port1.onmessage = (event) => {\n            this.onChannelMessage(event);\n        };\n\n        window.postMessage(req, window.origin, [this.messageChannel.port2]);\n\n        return new Promise((resolve, reject) => {\n            this.handshakeResolvers.set(req.responseId, {resolve, reject});\n            this.timeoutId = window.setTimeout(() => {\n                /*\n                 * Throw an error if neither HandshakeResponse nor original Handshake request are received in a reasonable timeframe.\n                 * This typically suggests an event handler stopped propagation of the Handshake request but did not respond to it on the MessageChannel port\n                 */\n                window.removeEventListener(\"message\", this.windowListener, false);\n                this.messageChannel.port1.close();\n                this.messageChannel.port2.close();\n                reject(BrowserAuthError.createNativeHandshakeTimeoutError());\n                this.handshakeResolvers.delete(req.responseId);\n            }, this.handshakeTimeoutMs); // Use a reasonable timeout in milliseconds here\n        });\n    }\n\n    /**\n     * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.\n     * @param event \n     */\n    private onWindowMessage(event: MessageEvent): void {\n        this.logger.trace(\"NativeMessageHandler - onWindowMessage called\");\n        // We only accept messages from ourselves\n        if (event.source !== window) {\n            return;\n        }\n\n        const request = event.data;\n\n        if (!request.channel || request.channel !== NativeConstants.CHANNEL_ID) {\n            return;\n        }\n\n        if (request.extensionId && request.extensionId !== this.extensionId) {\n            return;\n        }\n\n        if (request.body.method === NativeExtensionMethod.HandshakeRequest) {\n            // If we receive this message back it means no extension intercepted the request, meaning no extension supporting handshake protocol is installed\n            this.logger.verbose(request.extensionId ? `Extension with id: ${request.extensionId} not installed` : \"No extension installed\");\n            clearTimeout(this.timeoutId);\n            this.messageChannel.port1.close();\n            this.messageChannel.port2.close();\n            window.removeEventListener(\"message\", this.windowListener, false);\n            const handshakeResolver = this.handshakeResolvers.get(request.responseId);\n            if (handshakeResolver) {\n                handshakeResolver.reject(BrowserAuthError.createNativeExtensionNotInstalledError());\n            }\n        }\n    }\n\n    /**\n     * Invoked when a message is received from the extension on the MessageChannel port\n     * @param event \n     */\n    private onChannelMessage(event: MessageEvent): void {\n        this.logger.trace(\"NativeMessageHandler - onChannelMessage called.\");\n        const request = event.data;\n        \n        const resolver = this.resolvers.get(request.responseId);\n        const handshakeResolver = this.handshakeResolvers.get(request.responseId);\n\n        try {\n            const method = request.body.method;\n            \n            if (method === NativeExtensionMethod.Response) {\n                if (!resolver) {\n                    return;\n                }\n                const response = request.body.response;\n                this.logger.trace(\"NativeMessageHandler - Received response from browser extension\");\n                this.logger.tracePii(`NativeMessageHandler - Received response from browser extension: ${JSON.stringify(response)}`);\n                if (response.status !== \"Success\") {\n                    resolver.reject(NativeAuthError.createError(response.code, response.description, response.ext));\n                } else if (response.result) {\n                    if (response.result[\"code\"] && response.result[\"description\"]) {\n                        resolver.reject(NativeAuthError.createError(response.result[\"code\"], response.result[\"description\"], response.result[\"ext\"]));\n                    } else {\n                        resolver.resolve(response.result);\n                    }\n                } else {\n                    throw AuthError.createUnexpectedError(\"Event does not contain result.\");\n                }\n                this.resolvers.delete(request.responseId);\n            } else if (method === NativeExtensionMethod.HandshakeResponse) {\n                if (!handshakeResolver) {\n                    return;\n                }\n                clearTimeout(this.timeoutId); // Clear setTimeout\n                window.removeEventListener(\"message\", this.windowListener, false); // Remove 'No extension' listener\n                this.extensionId = request.extensionId;\n                this.extensionVersion = request.body.version;\n                this.logger.verbose(`NativeMessageHandler - Received HandshakeResponse from extension: ${this.extensionId}`);\n\n                handshakeResolver.resolve();\n                this.handshakeResolvers.delete(request.responseId);\n            } \n            // Do nothing if method is not Response or HandshakeResponse\n        } catch (err) {\n            this.logger.error(\"Error parsing response from WAM Extension\");\n            this.logger.errorPii(`Error parsing response from WAM Extension: ${err.toString()}`);\n            this.logger.errorPii(`Unable to parse ${event}`);\n\n            if (resolver) {\n                resolver.reject(err as AuthError);\n            } else if (handshakeResolver) {\n                handshakeResolver.reject(err as AuthError);\n            }\n        }\n    }\n\n    /**\n     * Returns the Id for the browser extension this handler is communicating with\n     * @returns \n     */\n    getExtensionId(): string | undefined {\n        return this.extensionId;\n    }\n\n    /**\n     * Returns the version for the browser extension this handler is communicating with\n     * @returns \n     */\n    getExtensionVersion(): string | undefined {\n        return this.extensionVersion;\n    }\n    \n    /**\n     * Returns boolean indicating whether or not the request should attempt to use native broker\n     * @param logger\n     * @param config\n     * @param nativeExtensionProvider\n     * @param authenticationScheme \n     */\n    static isNativeAvailable(config: BrowserConfiguration, logger: Logger, nativeExtensionProvider?: NativeMessageHandler, authenticationScheme?: AuthenticationScheme): boolean {\n        logger.trace(\"isNativeAvailable called\");\n        if (!config.system.allowNativeBroker) {\n            logger.trace(\"isNativeAvailable: allowNativeBroker is not enabled, returning false\");\n            // Developer disabled WAM\n            return false;\n        }\n\n        if (!nativeExtensionProvider) {\n            logger.trace(\"isNativeAvailable: WAM extension provider is not initialized, returning false\");\n            // Extension is not available\n            return false;\n        }\n\n        if (authenticationScheme) {\n            switch(authenticationScheme) {\n                case AuthenticationScheme.BEARER:\n                case AuthenticationScheme.POP:\n                    logger.trace(\"isNativeAvailable: authenticationScheme is supported, returning true\");\n                    return true;\n                default:\n                    logger.trace(\"isNativeAvailable: authenticationScheme is not supported, returning false\");\n                    return false;\n            }\n        }\n\n        return true;\n    }\n} \n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}